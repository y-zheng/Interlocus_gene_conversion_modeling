# Copy-Number Evolution Simulators — README

This repository contains forward-time R simulators for copy-number evolution at a locus under different biological assumptions:

- **Neutral locus, 2 copies** (`Neutral_locus_2copy.r`)
- **Neutral locus, 3 copies** (`Neutral_locus_3copy.r`)
- **Functional gene with purifying selection, 2 copies**  
  - Burn-in to mutation–selection balance (`Functional_locus_prepare.r`)  
  - Two-copy evolution with similarity-dependent IGC (`Functional_locus_2copy.r`)
- **Functional gene with long vs. short introns, 2 copies**  
  - Burn-in (`Functional_locus_longshort_intron_prepare.r.`)  
  - Two-copy evolution with similarity-dependent IGC (`Functional_locus_longshort_intron_2copy.r`)

All scenarios start from the **same neutral initial population** generated by `ms` (or `scrm`) and formatted as lines like `g010011…` (one haplotype per line).

---

## 1) Prerequisites

- **R** (≥ 4.0 recommended)
- R package: **abind**
- A neutral initial haplotype file from **ms** or **scrm** (see below)
- Recommended: a Unix shell for the example commands

Install the R dependency once:
```r
install.packages("abind")
```

---

## 2) Generate the *neutral* starting population (used by **all** scenarios)

The scripts assume **Ne = 2000** diploids (→ 4000 haplotypes). Use any coalescent simulator; below is an `ms` example that produces one replicate.

```bash
# Make input folders
mkdir -p Neutral_Initial Round3.5_Initial

# Generate 4000 haplotypes with ms (tune -t and -s for your θ and desired site count)
ms 4000 1 -t 200 -s 500 | \
  awk '/^positions:/{ for(i=0;i<4000;i++){ getline; print "g"$0 } }' \
  > Neutral_Initial/Neutral_inieq_rep_1.txt

# Functional scenarios look for the same file under Round3.5_Initial with a different name:
cp Neutral_Initial/Neutral_inieq_rep_1.txt Round3.5_Initial/Round3.5_inieq_rep_1.txt
```

> **Format required**: exactly **2×Ne** lines; each line is `g` + a fixed-length 0/1 string (same number of sites across lines).

---

## 3) Directory conventions & outputs

Each script writes into its own prefix folder with parameterized filenames:

- **Neutral 2-copy** → `Round1.5/`  
- **Neutral 3-copy** → `Round2.5/`  
- **Functional (burn-ins)** → `Round3.5_Initial/`  
- **Functional 2-copy (simple gene)** → `Round3.5_OL/`  
- **Functional 2-copy (long/short introns)** → `Round3.5_NL/`

Common output types:
- `*_stats.txt` — time series every 100 generations (θπ, θW, divergence, FST, etc.).  
- `*_gen_200000_copy_*.txt`, `*_pos.txt`, `*_copynumber.txt` — final population snapshot at 200,000 generations (if the duplicate persists).  
- `*_failrecord_copy2.txt` or `*_failrecord_copy3.txt` — indicates a copy was lost; the script **restarts** automatically.

> The simulators are stochastic; results vary per run/replicate. By design, runs **restart** when a new copy is lost, so seeing a `failrecord_*` is normal.

---

## 4) How to run each scenario

### A. Neutral locus — **2 copies**
Script: `Neutral_locus_2copy.r`  
**Usage:**
```bash
Rscript Neutral_locus_2copy.r <sel> <gcr> <gcml> <rec.rate> <rep>
```
- `sel` — selection per extra copy (e.g., `0.01` → fitness multiplier `(1+sel)^(diploid_copies-2)`)
- `gcr` — per-nucleotide IGC rate
- `gcml` — mean IGC tract length (bp)
- `rec.rate` — reciprocal recombination probability
- `rep` — replicate label (matches the input filename)

**Example:**
```bash
mkdir -p Round1.5
Rscript Neutral_locus_2copy.r 0.01 1e-8 100 1e-8 1
```
**Input expected:** `Neutral_Initial/Neutral_inieq_rep_<rep>.txt`  
**Outputs:** `Round1.5/Round1.5_adapt_<sel>_rec_<rec.rate>_GC_<gcr>_length_<gcml>_rep_<rep>_*`  
(Stats: `*_stats.txt`; final population files at 200k generations)  
**Reference:** script internals and I/O paths. fileciteturn4file7

---

### B. Neutral locus — **3 copies**
Script: `Neutral_locus_3copy.r`  
**Usage:**
```bash
Rscript Neutral_locus_3copy.r <sel> <gcr> <gcml> <dup.time> <rec.rate> <rep>
```
- `sel` — selection per extra copy
- `gcr` — per-nucleotide IGC rate
- `gcml` — mean IGC tract length (bp)
- `dup.time` — generation when the **third copy** is created from the second
- `rec.rate` — reciprocal recombination probability (copy 3 uses `2×rec.rate`)
- `rep` — replicate label

**Example:**
```bash
mkdir -p Round2.5
Rscript Neutral_locus_3copy.r 0.01 1e-8 100 50000 1e-8 1
```
**Input expected:** `Neutral_Initial/Neutral_inieq_rep_<rep>.txt`  
**Outputs:** `Round2.5/Round2.5_adapt_<sel>_rec_<rec.rate>_GC_<gcr>_length_<gcml>_timeitv_<dup.time>_rep_<rep>_*`  
(One stats stream; final population files at 200k generations)  
**Reference:** arguments and output naming. fileciteturn4file6

---

### C. Functional gene — **2 copies** (purifying selection + similarity‑dependent IGC)

This scenario uses two scripts: a **burn‑in** to mutation–selection balance, then the **two‑copy** simulation.

#### C1. Burn-in to selection–mutation balance
Script: `Functional_locus_prepare.r`  
**Usage:**
```bash
Rscript Functional_locus_prepare.r <pur.sel> <rep>
```
- `pur.sel` — deleterious effect per derived **nonsynonymous** allele (multiplicative on diploids)
- `rep` — replicate label

**Example (40k generations):**
```bash
mkdir -p Round3.5_Initial
# uses Round3.5_Initial/Round3.5_inieq_rep_<rep>.txt as input
Rscript Functional_locus_prepare.r 0.001 1
```
**Outputs:** selection history file and snapshots at 10k / 20k / 30k / **40k**:  
`Round3.5_Initial/Round3.5_newlocus_inieq_pursel_<pur.sel>_rep_<rep>_g40k.txt` and `..._g40k_pos.txt` (these seed the two‑copy run). fileciteturn4file4

#### C2. Two-copy evolution with purifying selection and similarity-dependent IGC
Script: `Functional_locus_2copy.r`  
**Usage:**
```bash
Rscript Functional_locus_2copy.r <gcr> <gcml> <gc.log> <pur.sel> <rep>
```
- `gcr` — per-nucleotide IGC rate
- `gcml` — mean IGC tract length (bp)
- `gc.log` — strength of **IGC suppression by divergence** (acceptance ~ `exp(-100*gc.dist*gc.log)`)
- `pur.sel` — deleterious effect per derived nonsynonymous allele
- `rep` — replicate label

**Example:**
```bash
mkdir -p Round3.5_OL
# reads the 40k burn-in files as input
Rscript Functional_locus_2copy.r 1e-8 100 0.5 0.001 1
```
**Outputs:** three time-series files (one per site class) and a 200k snapshot:  
`Round3.5_OL/Round3.5_purifying_<pur.sel>_GC_<gcr>_length_<gcml>_pnlty_<gc.log>_rep_<rep>_*`  
(`*_nonsyn_stats.txt`, `*_syn_stats.txt`, `*_intron_stats.txt`, plus final population files) fileciteturn4file9

---

### D. Functional gene with **long vs. short introns** — 2 copies

Again two scripts: a **burn-in** using a genome with 6 intron classes, then the **two-copy** run that reports per‑class stats (nonsyn, syn, and introns 1–6). Introns span sizes of **3000, 1200, 600, 300, 60, 2840 bp** across six classes. fileciteturn4file3

#### D1. Burn-in
Script: `Functional_locus_longshort_intron_prepare.r`  
**Usage:**
```bash
Rscript Functional_locus_longshort_intron_prepare.r <pur.sel> <rep>
```
- Inputs the same neutral file you copied into `Round3.5_Initial/Round3.5_inieq_rep_<rep>.txt`
- Evolves **40k** generations under purifying selection

**Example:**
```bash
mkdir -p Round3.5_Initial
Rscript Functional_locus_longshort_intron_prepare.r 0.001 1
```
**Outputs:** `Round3.5_Initial/Round3.5_newlocus_inieq_pursel_<pur.sel>_rep_<rep>_g40k.txt` and `..._g40k_pos.txt`. fileciteturn4file0

#### D2. Two-copy evolution (long/short introns)
Script: `Functional_locus_longshort_intron_2copy.r`  
**Usage:**
```bash
Rscript Functional_locus_longshort_intron_2copy.r <gcr> <gcml> <gc.log> <pur.sel> <rep>
```
- Arguments have the same meaning as in **C2**
- Reads the **40k burn-in** files as input

**Example:**
```bash
mkdir -p Round3.5_NL
Rscript Functional_locus_longshort_intron_2copy.r 1e-8 100 0.5 0.001 1
```
**Outputs:** per-class stats (8 classes: nonsyn, syn, intron1–intron6) and a 200k snapshot:  
`Round3.5_NL/Round3.5NL_purifying_<pur.sel>_GC_<gcr>_length_<gcml>_pnlty_<gc.log>_rep_<rep>_*` fileciteturn4file5

---

## 5) Tips, notes, and reproducibility

- **Replicates:** set `<rep>` to any label (e.g., `1`, `2`, …); input/output filenames incorporate it.
- **Restarts on loss:** If a new copy is lost, scripts log a `*_failrecord_*` line and automatically restart from the appropriate point; this behavior is expected.
- **No fixed RNG seed** is set in the scripts; set one globally in R if you need bitwise reproducibility.
- **Performance:** 200k generations with Ne=2000 can be CPU-intensive; consider running per-scenario parameter sweeps as a job array.
- **Units:** `gcr` is per‑nucleotide; scripts internally convert to a **per-tract initiation rate** using `gcr/gcml`.
- **Output interpretation:** θπ and θW are reported overall and per copy; for functional models, summaries are **per site class** (nonsyn, syn, introns). Divergence is the mean **within-haplotype** Hamming distance between copies; FST is reported as both **sum across loci** and **mean per locus**.

---

## 6) Minimal end-to-end example

```bash
# 0) Make neutral input & copy for functional burn-ins
mkdir -p Neutral_Initial Round3.5_Initial
ms 4000 1 -t 200 -s 500 | awk '/^positions:/{ for(i=0;i<4000;i++){ getline; print "g"$0 } }' \
  > Neutral_Initial/Neutral_inieq_rep_1.txt
cp Neutral_Initial/Neutral_inieq_rep_1.txt Round3.5_Initial/Round3.5_inieq_rep_1.txt

# A) Neutral 2-copy
mkdir -p Round1.5
Rscript Neutral_locus_2copy.r 0.01 1e-8 100 1e-8 1

# B) Neutral 3-copy (third copy at generation 50k)
mkdir -p Round2.5
Rscript Neutral_locus_3copy.r 0.01 1e-8 100 50000 1e-8 1

# C) Functional gene (simple): burn-in then 2-copy
mkdir -p Round3.5_Initial Round3.5_OL
Rscript Functional_locus_prepare.r 0.001 1
Rscript Functional_locus_2copy.r 1e-8 100 0.5 0.001 1

# D) Functional gene (long/short introns): burn-in then 2-copy
mkdir -p Round3.5_Initial Round3.5_NL
Rscript Functional_locus_longshort_intron_prepare.r 0.001 1
Rscript Functional_locus_longshort_intron_2copy.r 1e-8 100 0.5 0.001 1
```

---

## 7) Questions / troubleshooting

- **“Input not found”**: check the folder and filename conventions for the scenario (see Sections 3–4).  
- **“Copy lost” with fail records**: expected; the script restarts automatically.  
- **Different θπ/θW scales per class**: values are normalized by the class length (20 kb overall; class-specific lengths differ by scenario).

If anything’s unclear, open an issue with your command line, script version, and the first 10 lines of the relevant `*_stats.txt`.
